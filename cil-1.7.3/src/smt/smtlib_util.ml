(* auto-generated by gt *)

(* no extra data from grammar file. *)
type extradata = unit;;
let initial_data() = ();;

let file = ref "stdin";;
let line = ref 1;;
type pos = int;;
let string_of_pos p = "line "^(string_of_int p);;
let cur_pd() = (!line, initial_data());;   (* "pd": pos + extradata *) 
type pd = pos * extradata;;

(** Utility functions on option types *)

module Opt = struct
  let to_list = function
    | Some x -> [x]
    | None -> []

  let get = function
    | Some x -> x
    | None -> failwith "Util.unopt applied to None"

  let get_or_else default = function
    | Some x -> x
    | None -> default

  let fold f init = function
    | Some x -> f init x
    | None -> init

  let map f = function
    | Some x -> Some (f x)
    | None -> None

  let iter f = function
    | Some x -> f x
    | None -> ()
end

(** Utility functions on lists *)

(** Generate a list of length [n] using generator [f] *)
let generate_list (f : int -> 'a) (n : int) : 'a list = 
  let rec mk_tl n acc = 
    if n <= 0 then acc 
    else mk_tl (n - 1) (f (n - 1) :: acc) 
  in mk_tl n []

(** Composition of [List.map] and [List.filter] *)
let filter_map p f xs =
  List.fold_right (fun x ys -> if p x then f x :: ys else ys) xs []

(** Composition of [List.filter] and [List.rev_map] *)
let filter_rev_map p f xs =
  List.fold_left (fun ys x -> if p x then f x :: ys else ys) [] xs

    
(** Composition of [List.map] and [List.partition] *)
let partition_map p f xs =
  List.fold_right (fun x (ys1, ys2) -> if p x then (f x :: ys1, ys2) else (ys1, f x :: ys2)) xs ([], [])

(** Composition of [List.split] and [List.map] *)
let map_split f xs =
  List.fold_right (fun x (ys, zs) -> let y, z = f x in y :: ys, z :: zs) xs ([], [])

(** Applies [fn] to the elements in [xs] until the result becomes Some _ *)
let rec find_map fn = function
  | [] -> None
  | x :: xs ->
      match fn x with
      | None -> find_map fn xs
      | v -> v

(** The obligatory flat map *)
let flat_map f ls = List.flatten (List.map f ls)

let print_int64 x = print_string (Int64.to_string x)

let gcd a b = 
  if a = 0L || b = 0L then 
    1L
  else 
    let open Big_int in
    let result = int64_of_big_int (gcd_big_int (big_int_of_int64 a) (big_int_of_int64 b)) in
    assert (result > 0L);
    result

(* assumes that the list has length >1 *)
let list_gcd = function
  | [] -> 1L
  | [x] -> Int64.abs x
  | lst -> List.fold_left gcd (List.hd lst) lst

let rec run_fixpt fn term = 
  let newTerm = fn term in
  if newTerm = term 
  then term 
  else run_fixpt fn newTerm

