#!/usr/bin/perl -w

# What it does:
#
# 1. Substitute 0 for (nil). There are two cases where (nil) is printed.
#   a) A function call returning a null value, e.g.,
#      int* p = null_returning_function();
#   b) In a memory variable name as in _dsn_mem_(nil).
# 2. Add declarations for _dsm_mem variables.
# 3. 

use strict;
use warnings;

my ($infilename, @bad) = @ARGV;
die "Too many arguments " if @bad;
die "missing filename " unless $infilename;

my %mem_vars = ();

# 
# Identify memory variables (i.e., _dsn_mem vars) with correct types.
# Assumes that the type information follows immediately in a comment in the
# form of, e.g,. '/*|int |*/'.
#
open INFILE, "<", $infilename or die $!;
while (<INFILE>) {
    while (m!(_dsn_mem_(0x[0-9a-fA-F]+|\(nil\)))/\*\|([^|]*)\|\*/!g) {
        my $key = $2 eq "(nil)" ? "0x0" : $2;
        if (!exists($mem_vars{$key})) {
            $mem_vars{$key} = $3;
        } else {
            # Type unrolling in the concrete pass should give a canonical type.
            die "$1: multiple types " if ($3 ne $mem_vars{$key});
        }
    }
}

open INFILE, "<", $infilename or die $!;
my $last_seen = "";
while (<INFILE>) {
    s/_dsn_mem_\(nil\)/_dsn_mem_0x0/g;
    s/ = \(nil\);/ = 0;/;
    print ($last_seen = $_);
    if (/^int main\(int argc/) {
        for my $key (keys %mem_vars) {
            print "  $mem_vars{$key} _dsn_mem_$key;\n";
        }
    }
}

if ($last_seen ne "} // main") {
    print "  // Looks like the concretized trace ran into a crash.\n";
    print "  // Adding an assert and a closing bracket for main.\n";
    print "  assert(0);\n";
    print "} // main";
}
