#!/usr/bin/perl -w
# takes a linear output from cilly, and mangles it to be executable
# this is necessary because we might not have closed braces due to crashes
# also, we need to decide for each function call, whether to leave the call in place
# or to 

#TODO Change this to use passed params not a global array

use strict;
use warnings;
use constant {TRUE => 1,FALSE => 0};
use constant {DEFAULT_STATE => 0, IN_CALL_SETUP => 1, DONE_SETUP => 2};


my $spacesPerIndent = 2;
main();


sub indentLevel {
    my ($line, @bad) = @_;
    die "Too many arguments " if @bad;

# see http://stackoverflow.com/questions/3916852/how-can-i-count-the-amount-of-spaces-at-the-start-of-a-string-in-perl
    my $numLeadingSpaces = length( ($line =~ m/^( *)/)[0] );
    return ($numLeadingSpaces / $spacesPerIndent);
}

sub closeBraces {
    my ($lines, @bad) = @_;
    die "Too many arguments " if @bad;
    my $lastLine = @$lines[-1];
    my $closingBraces = printCloseBraces(indentLevel($lastLine),0);
    push $lines,$closingBraces;
}


sub indentSpaces {
    my ($i, @bad) = @_;
    die "Too many arguments " if @bad;
    
    return " " x ($i * $spacesPerIndent);
}
    

sub printCloseBraces {
    my ($initial,$final,@bad) = @_;
    die "Too many arguments " if @bad;

    my @newlines;
    for (my $i = $initial; $i > $final; $i--){
	#always close an indent at one level lower
	my $indent = indentSpaces ($i -1);
	my $newline = $indent . "}\n";
	push @newlines, $newline;
    }
    return @newlines;
}

sub instantiateCalls {
    my ($arrayRef,@bad) = @_;
    die "Too many arguments " if @bad;
    
    my @output;
    my $state = DEFAULT_STATE;
    my $currentCall;
    my @callSetup;
        
    foreach my $line (@$arrayRef) {
	print "$state: $line";
	if($state == IN_CALL_SETUP) {
	    if ($line =~ m/^\s*\/\/done setup/){
		$state = DONE_SETUP;
	    } else {
		push @callSetup, $line;
		$state = IN_CALL_SETUP;
	    }
	} 
	
	elsif ($state == DONE_SETUP) {
	    if ($line =~ m/^\s*\/\/enter/) {
		push @output, $currentCall;
		push @output, @callSetup;
		undef @callSetup;
		undef $currentCall;
		$state = DEFAULT_STATE;
	    } else {
		#the first non line number thing was not an entry.  So we are not in
		# the function.  So we don't need the setup stuff.  But we do need the call
		$currentCall =~  m/^\s*\/\/call(.*)/;
		my $actualCall = $1;
		push @output, $actualCall;
		push @output, $line;
		undef @callSetup;
		undef $currentCall;
		$state = DEFAULT_STATE;
	    }
	} 
	
	elsif ($state == DEFAULT_STATE) {	
	    if ($line =~ m/^\s*\/\/call/){
		$currentCall = $line;
		$state = IN_CALL_SETUP;
	    } else {
		push @output, $line;
		$state = DEFAULT_STATE;
	    }
	} 
	
	else { 
	    die "improper state";
	}
    }
    return @output;
}

sub main {
    my ($infilename, @bad) = @ARGV;
    die "Too many arguments " if @bad;
    die "missing filename " unless $infilename;
    print "foo\n";


    open INFILE, "<", $infilename or die $!;
    my @infile = <INFILE>;

    closeBraces(\@infile);
    my @instantiatedCalls = instantiateCalls(\@infile);

    
    foreach my $line (@instantiatedCalls){
	print $line;
    }
}



