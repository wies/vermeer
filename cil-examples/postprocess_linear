#!/usr/bin/perl -w
# takes a linear output from cilly, and mangles it to be executable
# this is necessary because we might not have closed braces due to crashes
# also, we need to decide for each function call, whether to leave the call in place
# or to 

#TODO Change this to use passed params not a global array

use strict;
use warnings;
use constant {TRUE => 1,FALSE => 0};
use constant {DEFAULT_STATE => 0, IN_CALL_SETUP => 1, DONE_SETUP => 2};

my $infilename = shift;
my $spacesPerIndent = 2;

open INFILE, "<", $infilename or die $!;
my @lines = <INFILE>;

sub indentLevel {
    my ($line, @bad) = @_;
    die "Too many arguments " if @bad;

# see http://stackoverflow.com/questions/3916852/how-can-i-count-the-amount-of-spaces-at-the-start-of-a-string-in-perl
    my $numLeadingSpaces = length( ($line =~ /^( *)/)[0] );
    return ($numLeadingSpaces / $spacesPerIndent);
}

sub closeBraces {
        push @lines, printCloseBraces(indentLevel($lines[-1]),0);
}

sub indentSpaces {
    my ($i, @bad) = @_;
    die "Too many arguments " if @bad;
    
    return " " x ($i * $spacesPerIndent);
}
    

sub printCloseBraces {
    my ($initial,$final,@bad) = @_;
    die "Too many arguments " if @bad;

    my @newlines;
    for (my $i = $initial; $i > $final; $i--){
	#always close an indent at one level lower
	my $indent = indentSpaces ($i -1);
	my $newline = $indent . "}\n";
	push @newlines, $newline;
    }
    return @newlines;
}

sub instantiateCalls {
    my ($arrayRef,@bad) = @_;
    die "Too many arguments " if @bad;
    
    my @output;
    my $state = DEFAULT_STATE;
    my $currentCall;
    my @callSetup;
    my @doneSetup;
    
    
    foreach my $line (@$arrayRef) {
	if($state == IN_CALL_SETUP) {
	    if ($line =~ m/^\s*\/\/done setup/){
		$state = DONE_SETUP;
	    } else {
		push @callSetup, $line;
	    }
	} 
	
	elsif ($state == DONE_SETUP) {
	    push @doneSetup, $line;
	    if ($line =~ m/^#/){
		#do nothing
	    } elsif ($line =~ m/^\s*\/\/enter/) {
		push @output, $currentCall;
		push @output, @callSetup;
		push @output, @doneSetup;
		undef @callSetup;
		undef @doneSetup;
		undef $currentCall;
	    } else {
		#the first non line number thing was not an entry.  So we are not in
		# the function.  So we don't need the setup stuff.  But we do need the call
		$currentCall =~  m/^\s*\/\/call(.*)/;
		my $actualCall = $1;
		push @output, $actualCall;
	    }
	} 
	
	elsif ($state == DEFAULT_STATE) {	
	    if ($line =~ m/^\s*\/\/call/){
		$currentCall = $line;
		$state = IN_CALL_SETUP;
	    } else {
		push @output, $line;
	    }
	} 
	
	else { 
	    die "improper state";
	}
    }
    return @output;
}

sub main {
    closeBraces();
    
    foreach my $line (@lines){
	print $line;
    }
}



main();
