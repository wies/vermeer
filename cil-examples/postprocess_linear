#!/usr/bin/perl -w
# takes a linear output from cilly, and mangles it to be executable
# this is necessary because we might not have closed braces due to crashes
# also, we need to decide for each function call, whether to leave the call in place
# or to 


#TODO Handle returns and gotos

use strict;
use warnings;
use constant {TRUE => 1,FALSE => 0};
use constant {DEFAULT_STATE => 0, 
	      CALL_FOUND => 1,
	      CALL_WAS_INLINED => 2,
	      COLLECTING_SCOPE => 3}


my $spacesPerIndent = 2;
main();

sub isOpenBrace {
    my ($line, @bad) = @_;
    die "Too many arguments " if @bad;

    return line =~ m/^\s{/;
}
sub isCloseBrace {
    my ($line, @bad) = @_;
    die "Too many arguments " if @bad;

    return line =~ m/^\s}/;
}


sub indentLevel {
    my ($line, @bad) = @_;
    die "Too many arguments " if @bad;

# see http://stackoverflow.com/questions/3916852/how-can-i-count-the-amount-of-spaces-at-the-start-of-a-string-in-perl
    my $numLeadingSpaces = length( ($line =~ m/^( *)/)[0] );
    return ($numLeadingSpaces / $spacesPerIndent);
}

sub closeBraces {
    my ($lines, @bad) = @_;
    die "Too many arguments " if @bad;
    my $lastLine = @$lines[-1];
    my $closingBraces = printCloseBraces(indentLevel($lastLine),0);
    push $lines,$closingBraces;
}


sub indentSpaces {
    my ($i, @bad) = @_;
    die "Too many arguments " if @bad;
    
    return " " x ($i * $spacesPerIndent);
}
    

sub printCloseBraces {
    my ($initial,$final,@bad) = @_;
    die "Too many arguments " if @bad;

    my @newlines;
    for (my $i = $initial; $i > $final; $i--){
	#always close an indent at one level lower
	my $indent = indentSpaces ($i -1);
	my $newline = $indent . "}\n";
	push @newlines, $newline;
    }
    return @newlines;
}

sub callWasInlinedInScope {
    my ($arrayRef,@bad) = @_;
    die "Too many arguments " if @bad;

    foreach my $line (@$arrayRef) {
	if ($line =~ m/^\s*\/\/enter/) {
	    return TRUE;
	}
    }
    return FALSE;
}


#given a piece of code, instantiate the calls relevent for that code
#if something is inlined, then we need to create temporary variables for
#it; otherwise, we need to create the formal call
sub instantiateCalls {
    my ($arrayRef,@bad) = @_;
    die "Too many arguments " if @bad;
    
    my @output;
    my $state = DEFAULT_STATE;
    my $currentCall;
    my $indentDepth;
    my @callSetup;
        
    foreach my $line (@$arrayRef) {
	#print "$state: $line";
	if ($state == DEFAULT_STATE) {	
	    if ($line =~ m/^\s*\/\/call/){
		$currentCall = $line;
		$state = CALL_FOUND;
	    } else {
		push @output, $line;
		$state = DEFAULT_STATE;
	    }
	} 

	#collect the 
	elsif ($state == CALL_FOUND) {
	    #the first line after is an open brace
	    isOpenBrace($line) or die "not an open brace";
	    $indentDepth = indentLevel($line);
	    $state = COLLECTING_SCOPE;
	}

	elsif ($state == COLLECTING_SCOPE) {
	    





	    if (isClosingBrace($line)){
		#finished the setup without entering the call
		$currentCall =~  m/^\s*\/\/call(.*)/;
		my $actualCall = $1;
		push @output, $actualCall;
		undef @callSetup;
		undef $currentCall;
		$state = DEFAULT_STATE;
	    } elsif ($line =~ m/^\s*\/\/enter/) {
		#there was a call!
		push @callSetup, $line;
		$state = CALL_WAS_INLINED;
	    } else {
		push @callSetup, $line;
		$state = CALL_FOUND;
	    }
	}

	elsif($state == CALL_WAS_INLINED) {
	    if (isClosingBrace($line)){
		

	    if ($line =~ m/^\s*\/\/done setup/){
		$state = DONE_SETUP;
	    } else {
		push @callSetup, $line;
		$state = IN_CALL_SETUP;
	    }
	} 
	
	elsif ($state == DONE_SETUP) {
	    if ($line =~ m/^\s*\/\/enter/) {
		push @output, $currentCall;
		push @output, @callSetup;
		undef @callSetup;
		undef $currentCall;
		$state = DEFAULT_STATE;
	    } else {
		#the first non line number thing was not an entry.  So we are not in
		# the function.  So we don't need the setup stuff.  But we do need the call
		$currentCall =~  m/^\s*\/\/call(.*)/;
		my $actualCall = $1;
		push @output, $actualCall;
		push @output, $line;
		undef @callSetup;
		undef $currentCall;
		$state = DEFAULT_STATE;
	    }
	} 
 
	else { 
	    die "improper state";
	}
    }
    return @output;
}

sub main {
    my ($infilename, @bad) = @ARGV;
    die "Too many arguments " if @bad;
    die "missing filename " unless $infilename;
    print "foo\n";


    open INFILE, "<", $infilename or die $!;
    my @infile = <INFILE>;

    closeBraces(\@infile);
    my @instantiatedCalls = instantiateCalls(\@infile);

    
    foreach my $line (@instantiatedCalls){
	print $line;
    }
}



